import { ValidationError, ValidationErrorItem } from 'sequelize';
import { User } from '../models/User';
import { IRegistrationData, IUserNonSensitive } from '../interfaces/user';
import { pbkdf2, randomBytes } from 'crypto';
import { promisify } from 'util';

const pbkdf2Async = promisify(pbkdf2);

class UserService {
    /**
     * Register a user
     * @param user {IRegistrationData} User registration data
     * @returns {Promise<IUserNonSensitive>}
     */
    public async registerUser(user: IRegistrationData) {
        const salt = this.generateSalt();
        const hashedPassword = await this.hashPassword(user.password, salt);
        return this.createUser(user, hashedPassword);
    }

    /**
     * Check if the email provided is already exists
     * @param email {string} email to check
     * @returns
     */
    public async checkIfEmailExists(email) {
        const user = await User.findOne({ where: { email } });
        return !!user;
    }

    /**
     * Check if a provided password matches the stored password
     * @param storedPassword {string} Stored password (from the database), hashed + salted
     * @param providedPassword {string} Provided password (from the request), plain text
     * @returns
     */
    public async verifyPassword(storedPassword, providedPassword) {
        const [salt] = storedPassword.split('$');
        const hash = await this.hashPassword(providedPassword, salt);
        return hash === storedPassword;
    }

    /**
     * Create a random salt
     * @returns {string} A random string to be used as salt
     */
    private generateSalt() {
        return randomBytes(16).toString('hex');
    }

    /**
     * Hash a password with a salt
     * @param password entered password
     * @param salt salt generated by generateSalt() or retrieved from the database
     * @returns {Promise<string>} hashed password
     */
    private async hashPassword(password, salt) {
        const hash = await pbkdf2Async(password, salt, 310000, 32, 'sha512');
        return `${salt}$${hash.toString('hex')}`;
    }

    /**
     * Create a user
     * @param user {IRegistrationData} User registration data
     * @param hashedPassword {string} Hashed password
     * @returns {Promise<IUserNonSensitive>} Created user
     */
    private async createUser(user, hashedPassword) {
        try {
            const createdUser = await User.create({
                firstName: user.firstName,
                lastName: user.lastName,
                email: user.email,
                password: hashedPassword,
            });
            console.log('Created user with id:', createdUser.id);
            const userNonSensitive: IUserNonSensitive = {
                id: createdUser.id,
                firstName: createdUser.firstName,
                lastName: createdUser.lastName,
                email: createdUser.email,
                createdAt: createdUser.createdAt,
                updatedAt: createdUser.updatedAt,
            };
            return userNonSensitive; // return the non-sensitive user data
        } catch (error) {
            console.error(error);
            if (error instanceof ValidationError) {
                return error.errors?.map((error) => {
                    if (error instanceof ValidationErrorItem) {
                        return error.message;
                    }
                });
            }
            throw error;
        }
    }
}

export default new UserService();
